#! /usr/bin/env python

#########################################################################################
#                                                                                       #
#    LockPyck -- A Password Cracker Powered By Probabilistic Context free grammars      #
#    Copyright (C) 2016  Christian Belk -- cbelk88@gmail.com                            #
#                                                                                       #
#    This program is free software: you can redistribute it and/or modify               #
#    it under the terms of the GNU General Public License as published by               #
#    the Free Software Foundation, either version 3 of the License, or                  #
#    (at your option) any later version.                                                #
#                                                                                       #
#    This program is distributed in the hope that it will be useful,                    #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of                     #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      #
#    GNU General Public License for more details.                                       #
#                                                                                       #
#    You should have received a copy of the GNU General Public License                  #
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.              #
#                                                                                       #
#########################################################################################

# This file contains the cartesianPreterms function and it's helpers. It is used to generate
# the cartesian product of the sets of termianls. As it generates each element, it converts
# it to a preterm and adds it to the queue.
#
# Author: Christian Belk

import qutility
import utility

# cartesianPreterms takes a list of lists (the sets), the queue, and the non-term. It then generates the cartesian
# product by first initializing the index for all sets to 0 (which is the first element in the product). 
# Then starting with the last set, it increments the index, each time generating a new element in the product.
# Everytime a new element in the product is generated, it is made into a preterm and added to the queue. When 
# the current set index can't be incremented anymore (ie the last element in that set has been used), curr_index 
# is set to the index of the next set down in the list, that set's index is incremented and the indexes of all 
# sets higher in the list than the current one are reset to 0 (whch is the next element in the product). The 
# process is then repeated starting with incrementing the last set.
def cartesianPreterms(sets, queue, poison_queue, nonterm):
    lengths = []
    indexes = []
    THRESHOLD = 80
    for s in sets:
        lengths.append(len(s))
        indexes.append(0)
    curr_ind = len(indexes) - 1
    while True:
        if qutility.poisoned(poison_queue):
            print '[+] CartersianPreterm: Recieved poison pill! Terminating ...'
            return
        utility.courtesyCheck(THRESHOLD)
        partTerm = getPartialTerminal(sets, indexes)
        queue.put([partTerm, nonterm])
        if weDoneYet(lengths, indexes):
            break
        if indexes[curr_ind] < lengths[curr_ind]:
            indexes[curr_ind] += 1
        if indexes[curr_ind] == lengths[curr_ind]:
            curr_ind -= 1
            while curr_ind >= 0 and indexes[curr_ind] + 1 == lengths[curr_ind]:
                curr_ind -= 1
            indexes[curr_ind] += 1
            curr_ind += 1
            while curr_ind < len(indexes):
                indexes[curr_ind] = 0
                curr_ind += 1
            curr_ind -= 1
    return

# getPartialTerminal produces a preterm by concatenating the elements at each index in the respective set.
def getPartialTerminal(sets, indexes):
    partTerm = ''
    for i in xrange(len(indexes)):
        partTerm += sets[i][indexes[i]]
    return partTerm

# weDoneYet determines if all the elements from the cartesian product have been generated by checking if
# the indexes are equal to their respective lengths - 1.
def weDoneYet(lengths, indexes):
    for i in xrange(len(indexes)):
        if indexes[i] < (lengths[i] - 1):
            return False
    return True
